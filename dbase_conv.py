#!/usr/bin/python3
#
# Converts Smart IC Tester database file into a C header file.
# This script is based on: https://github.com/Johnlon/integrated-circuit-tester
# Ver. 3
# - Uses simple compression algorithm to reduce size (output is ~ 55% of the original size).
# - Ignores test lines starting with # to allow test comments.
# - Original (decompressed) test definitions are also stored in the .h file
#   as comments. This allows to check the tests while looking at the .h file.
# - Checks the total size of the decompressed test to prevent Arduino Nano crashes
#   caused by RAM size limitations. The Arduino code could be optimized to support longer
#   tests by decompressing individual tests on the fly rather than all tests in one go.
#   Current limit is 528 decompressed test characters per single IC.

# https://github.com/Johnlon/integrated-circuit-tester

import sys
import urllib.request


name = ""
desc = ""
tests=[]
readtests = False
pinNo= ""
chips=[]
firstRecord = True
longLen = 0
shortLen = 0;

#src="https://raw.githubusercontent.com/akshaybaweja/Smart-IC-Tester/master/database.txt"
#page = urllib.request.urlopen(src)
#databaseTxtResp=page.read().decode("utf-8")
#databaseTxt = databaseTxtResp.split("\n")

databaseTxt = open("database.txt", "r")
chipsDatabaseIno = open("ic_dbase.h", "w")

# This is the compression scheme string to swap 2 byte string into single byte character.
# For example: 00 -> a, 11 -> b, 01-> c, etc.
#         a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  {  |  }
#        "00 11 01 10 HH LL LH HL L0 L1 H0 H1 C0 0H G0 0L 1L 0G XX HG 1H GH GC GL 1G V  Z1 Z0 ZZ"
tokens = "00110110HHLLLHHLL0L1H0H1C00HG00L1L0GXXHG1HGHGCGL1GV Z1Z0ZZ"

def replaceTokens(line):

    l = len(tokens)
    i = 0
    r = " "

#   special 4 byte translations
    line = line.replace("0000", "-");
    line = line.replace("1111", "+");
    line = line.replace("HHHH", "*");
    line = line.replace("LLLL", "/");
    line = line.replace("ZZZZ", "[");

    while (i < l):
#              'a' + (i / 2)
        r = chr(97 + (i >> 1))
        t = tokens[i] + tokens[i + 1]
        i = i + 2
        line = line.replace(t, r);

    return line

# --------------------------------------------------------------------------
# Start of the conversion
# --------------------------------------------------------------------------
# how this parsing algorithm works:
# * lines are parsed first and then writen only AFTER the NEXT chip record
#   is encountered. So when it reads the second line with $ it writes the data
#   of the first record.
# * last text line in the database is '$' therefore it triggers write of the
#   last record and finishes reading.
# * at the end it writes the tail of the export - the IC list

for line in databaseTxt:
    line = line.strip()
    # export data of the previous record (if it exists)
    if (line.startswith("$")):
        size = len(tests)
        if (name != "") and (size < 34) and ( ((pinNo == "20") and (tests[0].find('G') == 9)) or ((pinNo == "14") and (tests[0].find('G') == 6)) or ((pinNo == "16") and (tests[0].find('G') == 7))) :
            # write the .h file header
            if firstRecord == True:
                firstRecord = False
                chipsDatabaseIno.write("// Generated by dbase_conv.py\n\n")
                chipsDatabaseIno.write("const char decode_tokens[] PROGMEM = \"%s\";\n" % (tokens))

            print("Chip %s (%s)" % (name, pinNo) )
            chips.append(name)
            chipsDatabaseIno.write("// %s : %s\n" % (name, desc))
            chipsDatabaseIno.write("const char name_%s[] PROGMEM = \"%s\";\n" % (name, name))

            chipsDatabaseIno.write("const char tests_%s[] PROGMEM = \\\n" % (name))

            i = 0
            fullLine = ""
            for test in tests:
                i = i + 1
                if (i == size):
                    fullLine = fullLine + test
                else:
                    fullLine = fullLine + test + " "
            shortLine = replaceTokens(fullLine)
            chipsDatabaseIno.write("\t\"%s\";\n\n" % shortLine)
            fllen = len(fullLine)
            longLen = longLen + fllen
            shortLen = shortLen + len(shortLine)

            if (fllen > 528):
                print("Error: test string is too long: %s (%i)" % (name,fllen))
            else:
                i = 0
                for test in tests:
                    i = i + 1
                    # last item
                    if (i == size):
                        chipsDatabaseIno.write("//\t\"%s\";\n\n" % test)
                    else:
                        chipsDatabaseIno.write("//\t\"%s \" \\\n" % test)


#        else:
#            print("No export for %s" % pinNo)

        name = ""
        desc = ""
        tests=[]
        sys.stdout.flush()
        readtests = False

    # end of the document found - write the chip list and exit
    if (line == "$"):
        chipsDatabaseIno.write("const char* ic_tests[] = {\n")
        for chip in chips:
            chipsDatabaseIno.write("\tname_%s, tests_%s,\n" % (chip, chip))

        chipsDatabaseIno.write("};\n")

        print("Long text len : %i" % longLen)
        print("Short text len: %i" % shortLen)
        compressed = shortLen / (longLen / 100)
        print("Shrunk to %i %% of the original size" % compressed)
        break

    # new IC record found
    if (line.startswith("$")):
        tests=[]
        name = line.replace("$","",1)
        desc = ""
        # print("->> detected name %s" % name)
    # record data line found
    else:
        #parse description
        if desc == "":
            desc = line
            # print("->> detected description %s" % desc)
        else:
            # parse total pins line
            if readtests == False:
                readtests = True
                pinNo = line
                # print("->> detected pin count %s" % pinNo)
            # parse tests
            else:
                # ignore test lines that start with hash - these are comments
                if not line.startswith("#"):
                    tests.append(line)
                #else:
                #    print("Ignoring comment: %s" % line)
